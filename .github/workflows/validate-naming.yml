name: validate-naming

on:
  push:
    branches:
      - test-branch

jobs:
  validate-naming:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Validate project names (.project files) for kebab-case
        id: validate_projects
        shell: bash
        continue-on-error: true
        run: |
          echo "üîç STEP 1: Validating project names (.project files) for kebab-case..."
          violations=0

          is_kebab_case() {
            [[ "$1" =~ ^[a-z0-9]+(-[a-z0-9]+)*$ ]]
          }

          IFS=$'\n'
          project_files=($(find . -type f \( -name ".project" -o -name "*.project" \)))

          echo "üîé Found ${#project_files[@]} .project files"

          for project_file in "${project_files[@]}"; do
            proj_name=$(grep -oPm1 '(?<=<name>)[^<]+' "$project_file" || echo "")

            if [[ -z "$proj_name" ]]; then
              echo "‚ùå ERROR: No <name> tag found in $project_file"
              echo "::error file=$project_file::Missing <name> tag"
              violations=$((violations + 1))
              continue
            fi

            if [[ "$proj_name" == *.module ]]; then
              core_name="${proj_name%.module}"
            elif [[ "$proj_name" == *.parent ]]; then
              core_name="${proj_name%.parent}"
            else
              core_name="$proj_name"
            fi

            if ! is_kebab_case "$core_name"; then
              echo "‚ùå ERROR: Invalid project name '$proj_name' (found in $project_file)"
              echo "::error file=$project_file::Invalid project name '$proj_name'. Expected kebab-case"
              violations=$((violations + 1))
            fi
          done

          echo "project_violations=$violations" >> "$GITHUB_OUTPUT"

      - name: Validate process, activity, variable, and schema names
        id: validate_processes
        shell: bash
        continue-on-error: true
        run: |
          echo "üîç STEP 2: Validating naming conventions (processes, activities, variables, schemas)..."

          camel_case_regex='^[a-z]+([A-Z][a-z0-9]*)*$'
          pascal_case_regex='^[A-Z][a-z0-9]+([A-Z][a-z0-9]*)*$'
          special_char_regex='[%$@_#]'

          violations=0

            # ‚úÖ PROCESS FILE (.bwp) checks
            mapfile -t bwp_files < <(find . -type f -name "*.bwp")
            echo "üîé Found ${#bwp_files[@]} .bwp files"

            for file in "${bwp_files[@]}"; do
              filename=$(basename "$file")
              base="${filename%.bwp}"

              if [[ ! "$base" =~ $camel_case_regex ]]; then
                echo "‚ùå ERROR: Process name '$base' must be camelCase (found in $file)"
                echo "::error file=$file::Invalid process name '$base'. Must be camelCase"
                violations=$((violations + 1))
              fi

              if [[ "$base" =~ $special_char_regex ]]; then
                echo "‚ùå ERROR: Process name '$base' contains special characters (found in $file)"
                echo "::error file=$file::Special characters not allowed in process name '$base'"
                violations=$((violations + 1))
              fi

            # ‚úÖ ACTIVITY (task name) checks
            echo "üîé Checking activity (task) names in: $filename"
            mapfile -t tasks < <(grep -oP '<[^:>]*task\b[^>]*name="\K[^"]+' "$file")

            for task in "${tasks[@]}"; do
              
              if [[ ! "$task" =~ $pascal_case_regex ]]; then
                echo "‚ùå ERROR: Activity name '$task' in $filename must be PascalCase"
                echo "::error file=$file::Activity name '$task' must be PascalCase"
                violations=$((violations + 1))
              fi
              if [[ "$task" =~ $special_char_regex ]]; then
                echo "‚ùå ERROR: Activity name '$task' contains special characters"
                echo "::error file=$file::Special characters not allowed in activity name '$task'"
                violations=$((violations + 1))
              fi
            done

          # ‚úÖ VARIABLE (.jsv / .msv) checks
          mapfile -t var_files < <(find . -type f \( -name "*.jsv" -o -name "*.msv" \))
          echo "üîé Found ${#var_files[@]} variable files (.jsv/.msv)"

          for vfile in "${var_files[@]}"; do
            filename=$(basename "$vfile")

            if [[ "$vfile" == *.jsv ]]; then
              vnames=$(grep -oP '<jobSharedVariable name="\K[^"]+' "$vfile" || true)
              var_type=".jsv"
            else
              vnames=$(grep -oP '<moduleSharedVariable name="\K[^"]+' "$vfile" || true)
              var_type=".msv"
            fi

            var_count=$(echo "$vnames" | grep -c . || true)

            if [[ "$var_count" -eq 0 ]]; then
              echo "üìÑ $filename ($var_type) contains 0 variables."
            else
              echo "üìÑ $filename ($var_type) contains $var_count variable(s):"
              echo "$vnames" | sed 's/^/   - /'
            fi

            while IFS= read -r var; do
              if [[ -z "$var" ]]; then continue; fi
              if [[ ! "$var" =~ $camel_case_regex ]]; then
                echo "‚ùå ERROR: Variable '$var' in $filename must be camelCase"
                echo "::error file=$vfile::Variable '$var' must be camelCase"
                violations=$((violations + 1))
              fi
              if [[ "$var" =~ $special_char_regex ]]; then
                echo "‚ùå ERROR: Variable '$var' in $filename contains special characters"
                echo "::error file=$vfile::Special characters not allowed in variable name '$var'"
                violations=$((violations + 1))
              fi
            done <<< "$vnames"
          done

          # ‚úÖ SCHEMA (.xsd) checks
          mapfile -t xsd_files < <(find . -type f -name "*.xsd")
          echo "üîé Found ${#xsd_files[@]} schema files (.xsd)"

          for xsd in "${xsd_files[@]}"; do
            filename=$(basename "$xsd")
            xname="${filename%.xsd}"

            if [[ ! "$xname" =~ $camel_case_regex ]]; then
              echo "‚ùå ERROR: Schema '$xname' must be camelCase"
              echo "::error file=$xsd::Schema filename '$xname.xsd' must be camelCase"
              violations=$((violations + 1))
            fi
            if [[ "$xname" =~ $special_char_regex ]]; then
              echo "‚ùå ERROR: Schema name '$xname' contains special characters"
              echo "::error file=$xsd::Special characters not allowed in schema name '$xname'"
              violations=$((violations + 1))
            fi
          done

          echo "process_violations=$violations" >> "$GITHUB_OUTPUT"

      - name: Validate presence of .substvar files in META-INF folders for specific environments
        id: validate_substvar
        shell: bash
        continue-on-error: true
        run: |
          echo "üîç STEP 3: Checking for .substvar files in META-INF folders..."

          violations=0
          envs="DEV4 IT UAT ST PT AM"

          # Step 1: Find all "META-INF" directories
          mapfile -t meta_dirs < <(find . -type d -name META-INF)

          # Step 2: Filter valid application directories (exclude paths like *.module)
          declare -A seen
          app_dirs=()
          for meta in "${meta_dirs[@]}"; do
            parent_dir=$(dirname "$meta")
            base=$(basename "$parent_dir" | tr '[:upper:]' '[:lower:]')
            if [[ "$parent_dir" == *".module"* ]]; then
              continue
            fi
            if [[ -z "${seen[$base]}" ]]; then
              seen[$base]=1
              app_dirs+=("$parent_dir")
            fi
          done

          echo "üîé Applications to validate:"
          for app in "${app_dirs[@]}"; do echo "$app"; done

          # Step 3: Check for each expected .substvar file
          for app_dir in "${app_dirs[@]}"; do
            meta_inf="$app_dir/META-INF"
            echo "üì¶ Validating application: $app_dir"

            for env in $envs; do
              if find "$meta_inf" -type f -iname "$env.substvar" | grep -iq "$env.substvar"; then
                echo "‚úÖ Found $env.substvar in $meta_inf"
              else
                echo "‚ö†Ô∏è Environment .substvar not found: $meta_inf/$env.substvar"
                echo "::warning file=$meta_inf/$env.substvar::Missing $env.substvar"
                violations=$((violations + 1))
              fi
            done
          done

          echo "substvar_violations=$violations" >> "$GITHUB_OUTPUT"

      - name: Fail job if any violations found
        if: |
          steps.validate_projects.outputs.project_violations != '0' || 
          steps.validate_processes.outputs.process_violations != '0' || 
          steps.validate_substvar.outputs.substvar_violations != '0'
        run: |
          echo "‚ùå Validation errors detected. Failing the job."
          exit 1
