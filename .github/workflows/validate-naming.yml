name: validate-naming

on:
  push:
    branches:
      - test-branch

jobs:
  validate-naming:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Validate project names (.project files) for kebab-case
        id: validate_projects
        shell: bash
        continue-on-error: true
        run: |
          echo "üîç STEP 1: Validating project names (.project files) for kebab-case..."
          violations=0

          is_kebab_case() {
            [[ "$1" =~ ^[a-z0-9]+(-[a-z0-9]+)*$ ]]
          }

          IFS=$'\n'
          project_files=($(find . -type f \( -name ".project" -o -name "*.project" \)))

          echo "üîé Found ${#project_files[@]} .project files"

          for project_file in "${project_files[@]}"; do
            proj_name=$(grep -oPm1 '(?<=<name>)[^<]+' "$project_file" || echo "")

            if [[ -z "$proj_name" ]]; then
              echo "‚ùå ERROR: No <name> tag found in $project_file"
              echo "::error file=$project_file::Missing <name> tag"
              violations=$((violations + 1))
              continue
            fi

            if [[ "$proj_name" == *.module ]]; then
              core_name="${proj_name%.module}"
            elif [[ "$proj_name" == *.parent ]]; then
              core_name="${proj_name%.parent}"
            else
              core_name="$proj_name"
            fi
            
            # ‚õî Must start with "om-"
            if [[ ! "$core_name" =~ ^om- ]]; then
              echo "‚ùå ERROR: Project name '$proj_name' must start with 'om-' (found in $project_file)"
              echo "::error file=$project_file::Project name '$proj_name' must start with 'om-'"
              violations=$((violations + 1))
            fi
            
            # ‚õî Length check
            if (( ${#core_name} > 3 )); then
              echo "‚ùå ERROR: Project name '$proj_name' exceeds 3 characters (found in $project_file)"
              echo "::error file=$project_file::Project name '$proj_name' exceeds 3 characters (limit: 3)"
              violations=$((violations + 1))
            fi
            
            # ‚õî Kebab-case check
            if ! is_kebab_case "$core_name"; then
              echo "‚ùå ERROR: Invalid project name '$proj_name' (found in $project_file)"
              echo "::error file=$project_file::Invalid project name '$proj_name'. Expected kebab-case"
              violations=$((violations + 1))
            fi
          done
          
          # ‚úÖ Success message if no violations
          if [[ "$violations" -eq 0 ]]; then
            echo "‚úÖ All project names are valid (start with 'om-', are ‚â§ 3 chars, and in kebab-case)."
          fi

          echo "project_violations=$violations" >> "$GITHUB_OUTPUT"

      - name: Validate process, activity, variable, and schema names
        id: validate_processes
        shell: bash
        continue-on-error: true
        run: |
         echo "üîç STEP 2: Validating naming conventions (processes, activities, variables, schemas)..."

            camel_case_regex='^[a-z]+([A-Z][a-z0-9]*)*$'
            pascal_case_regex='^[A-Z][a-z0-9]+([A-Z][a-z0-9]*)*$'
            special_char_regex='[%$@_#]'

            violations=0

            # ‚úÖ PROCESS FILE (.bwp) checks
            mapfile -t bwp_files < <(find . -type f -name "*.bwp")
            echo "üîé Found ${#bwp_files[@]} .bwp files"

            bwp_violations=0

            for file in "${bwp_files[@]}"; do
              filename=$(basename "$file")
              base="${filename%.bwp}"

              # Check process name
              if [[ ! "$base" =~ $camel_case_regex ]]; then
                echo "‚ùå ERROR: Process name '$base' must be camelCase (found in $file)"
                echo "::error file=$file::Invalid process name '$base'. Must be camelCase"
                violations=$((violations + 1))
                bwp_violations=$((bwp_violations + 1))
              fi

              if [[ "$base" =~ $special_char_regex ]]; then
                echo "‚ùå ERROR: Process name '$base' contains special characters (found in $file)"
                echo "::error file=$file::Special characters not allowed in process name '$base'"
                violations=$((violations + 1))
                bwp_violations=$((bwp_violations + 1))
              fi

              # ‚úÖ ACTIVITY (task name) checks inside each .bwp
              echo "üîé Checking activity (task) names in: $filename"
              mapfile -t tasks < <(grep -oP '<[^:>]*task\b[^>]*name="\K[^"]+' "$file")

              task_errors=0
              for task in "${tasks[@]}"; do
                if [[ ! "$task" =~ $pascal_case_regex ]]; then
                  echo "‚ùå ERROR: Activity name '$task' in $filename must be PascalCase"
                  echo "::error file=$file::Activity name '$task' must be PascalCase"
                  violations=$((violations + 1))
                  task_errors=$((task_errors + 1))
                fi
                if [[ "$task" =~ $special_char_regex ]]; then
                  echo "‚ùå ERROR: Activity name '$task' contains special characters"
                  echo "::error file=$file::Special characters not allowed in activity name '$task'"
                  violations=$((violations + 1))
                  task_errors=$((task_errors + 1))
                fi
              done

              if [[ ${#tasks[@]} -eq 0 ]]; then
                echo "‚ÑπÔ∏è No task activities found in $filename"
              elif [[ $task_errors -eq 0 ]]; then
                echo "‚úÖ All activity names are valid in $filename and contain no special characters."
              fi

            done

            if [[ "$bwp_violations" -eq 0 ]]; then
              echo "‚úÖ All .bwp process filenames follow camelCase and contain no special characters."
            fi

            # ‚úÖ VARIABLE (.jsv / .msv) checks
            mapfile -t var_files < <(find . -type f \( -name "*.jsv" -o -name "*.msv" \))
            echo "üîé Found ${#var_files[@]} variable files (.jsv/.msv)"

            var_violations=0
            jsv_violations=0
            msv_violations=0

            for vfile in "${var_files[@]}"; do
              filename=$(basename "$vfile")

              if [[ "$vfile" == *.jsv ]]; then
                vnames=$(grep -oP '<jobSharedVariable name="\K[^"]+' "$vfile" || true)
                var_type=".jsv"
              else
                vnames=$(grep -oP '<moduleSharedVariable name="\K[^"]+' "$vfile" || true)
                var_type=".msv"
              fi

              var_count=$(echo "$vnames" | grep -c . || true)

              if [[ "$var_count" -eq 0 ]]; then
                echo "üìÑ $filename ($var_type) contains 0 variables."
              else
                echo "üìÑ $filename ($var_type) contains $var_count variable(s):"
                echo "$vnames" | sed 's/^/   - /'
              fi

              while IFS= read -r var; do
                if [[ -z "$var" ]]; then continue; fi

                if [[ ! "$var" =~ $camel_case_regex ]]; then
                  echo "‚ùå ERROR: Variable '$var' in $filename must be camelCase"
                  echo "::error file=$vfile::Variable '$var' must be camelCase"
                  violations=$((violations + 1))
                  var_violations=$((var_violations + 1))
                  [[ "$var_type" == ".jsv" ]] && jsv_violations=$((jsv_violations + 1))
                  [[ "$var_type" == ".msv" ]] && msv_violations=$((msv_violations + 1))
                fi

                if [[ "$var" =~ $special_char_regex ]]; then
                  echo "‚ùå ERROR: Variable '$var' in $filename contains special characters"
                  echo "::error file=$vfile::Special characters not allowed in variable name '$var'"
                  violations=$((violations + 1))
                  var_violations=$((var_violations + 1))
                  [[ "$var_type" == ".jsv" ]] && jsv_violations=$((jsv_violations + 1))
                  [[ "$var_type" == ".msv" ]] && msv_violations=$((msv_violations + 1))
                fi
              done <<< "$vnames"
            done

            if [[ "$jsv_violations" -eq 0 ]]; then
              echo "‚úÖ All variables in .jsv files follow camelCase and contain no special characters."
            fi

            if [[ "$msv_violations" -eq 0 ]]; then
              echo "‚úÖ All variables in .msv files follow camelCase and contain no special characters."
            fi

          # ‚úÖ SCHEMA (.xsd) checks
          mapfile -t xsd_files < <(find . -type f -name "*.xsd")
          echo "üîé Found ${#xsd_files[@]} schema files (.xsd)"

          xsd_violations=0

          for xsd in "${xsd_files[@]}"; do
            filename=$(basename "$xsd")
            xname="${filename%.xsd}"

            if [[ ! "$xname" =~ $camel_case_regex ]]; then
              echo "‚ùå ERROR: Schema '$xname' must be camelCase"
              echo "::error file=$xsd::Schema filename '$xname.xsd' must be camelCase"
              violations=$((violations + 1))
              xsd_violations=$((xsd_violations + 1))
            fi
            if [[ "$xname" =~ $special_char_regex ]]; then
              echo "‚ùå ERROR: Schema name '$xname' contains special characters"
              echo "::error file=$xsd::Special characters not allowed in schema name '$xname'"
              violations=$((violations + 1))
              xsd_violations=$((xsd_violations + 1))
            fi
          done

          if [[ "$xsd_violations" -eq 0 ]]; then
            echo "‚úÖ All .xsd schema filenames follow camelCase and contain no special characters."
          fi

      - name: Validate presence of .substvar files in META-INF folders for specific environments
        id: validate_substvar
        shell: bash
        continue-on-error: true
        run: |
          echo "üîç STEP 3: Checking for .substvar files in META-INF folders..."

          violations=0
          envs="DEV4 IT UAT ST PT AM"

          # Step 1: Find all "META-INF" directories
          mapfile -t meta_dirs < <(find . -type d -name META-INF)

          # Step 2: Filter valid application directories (exclude paths like *.module)
          declare -A seen
          app_dirs=()
          for meta in "${meta_dirs[@]}"; do
            parent_dir=$(dirname "$meta")
            base=$(basename "$parent_dir" | tr '[:upper:]' '[:lower:]')
            if [[ "$parent_dir" == *".module"* ]]; then
              continue
            fi
            if [[ -z "${seen[$base]}" ]]; then
              seen[$base]=1
              app_dirs+=("$parent_dir")
            fi
          done

          echo "üîé Applications to validate:"
          for app in "${app_dirs[@]}"; do echo "$app"; done

          # Step 3: Check for each expected .substvar file
          for app_dir in "${app_dirs[@]}"; do
            meta_inf="$app_dir/META-INF"
            echo "üì¶ Validating application: $app_dir"

            for env in $envs; do
              if find "$meta_inf" -type f -iname "$env.substvar" | grep -iq "$env.substvar"; then
                echo "‚úÖ Found $env.substvar in $meta_inf"
              else
                echo "‚ö†Ô∏è Environment .substvar not found: $meta_inf/$env.substvar"
                echo "::warning file=$meta_inf/$env.substvar::Missing $env.substvar"
                violations=$((violations + 1))
              fi
            done
          done

          echo "substvar_violations=$violations" >> "$GITHUB_OUTPUT"
          
      - name: Validate required subfolders in Processes directory of the .module
        id: validate_process_structure
        shell: bash
        continue-on-error: true
        run: |
          echo "üîç STEP 4: Validating Processes subfolders (Frontend, Backend, Orchestration)..."

          violations=0
          expected_subdirs=("Frontend" "Backend" "Orchestration")

          module_dir=$(find . -type d -name "*.module" | head -n 1)
          processes_dir="$module_dir/Processes"

          echo "üìÇ Checking: $processes_dir"

          for sub in "${expected_subdirs[@]}"; do
            sub_dir="$processes_dir/$sub"
            if [[ ! -d "$sub_dir" ]]; then
              echo "‚ùå ERROR: Missing subfolder '$sub' in $processes_dir"
              echo "::error file=$sub_dir::$sub folder missing in Processes"
              violations=$((violations + 1))
            fi
          done

          if [[ "$violations" -eq 0 ]]; then
            echo "‚úÖ All Processes folders contain Frontend, Backend, and Orchestration subdirectories."
          fi

          echo "structure_violations=$violations" >> "$GITHUB_OUTPUT"
          
      - name: Validate REST path and parameter naming
        id: validate_rest_naming
        shell: bash
        continue-on-error: true
        run: |
          echo "üîç STEP 5: Validating REST path and parameter naming..."

          bwm_file="./namingcheck/Test.module/META-INF/module.bwm"
          violations=0
          path_param_violations=0
          query_param_violations=0
          path_format_violations=0

          if [[ ! -f "$bwm_file" ]]; then
            echo "‚ùå ERROR: File not found: $bwm_file"
            echo "::error file=$bwm_file::File not found"
            exit 1
          fi

          kebab_case_regex='^[a-z0-9]+(-[a-z0-9]+)*$'
          camel_case_regex='^[a-z]+([A-Z][a-z0-9]*)*$'

          echo "üîπ Validating REST resource paths..."
          mapfile -t paths < <(grep -oP 'RestServiceBinding[^>]*\spath="\K[^"]+' "$bwm_file")

          if [[ ${#paths[@]} -eq 0 ]]; then
            echo "‚ùå ERROR: REST resource path not found."
            echo "::error file=$bwm_file::REST resource path (path=\"...\") not found"
            exit 1
          fi

          for path in "${paths[@]}"; do
            echo "üî∏ Checking path: $path"
            cleaned_path=$(echo "$path" | sed 's#^/##;s#/$##')
            IFS='/' read -ra segments <<< "$cleaned_path"
            for segment in "${segments[@]}"; do
              [[ "$segment" =~ ^\{.*\}$ ]] && continue
              if [[ ! "$segment" =~ $kebab_case_regex ]]; then
                echo "::error file=$bwm_file::Path segment '$segment' in '$path' must be kebab-case"
                path_format_violations=$((path_format_violations + 1))
              fi
            done
          done

          if [[ "$path_format_violations" -eq 0 ]]; then
            echo "‚úÖ REST path segments passed kebab-case validation."
          fi

          # Path Parameters
          mapfile -t path_params < <(grep 'parameterMapping' "$bwm_file" | grep 'parameterType="Path"')
          if [[ ${#path_params[@]} -gt 0 ]]; then
            echo "üîπ Validating Path Parameters..."
            for line in "${path_params[@]}"; do
              name=$(echo "$line" | grep -oP 'parameterName="\K[^"]+')
              echo "- Path parameter: $name"
              if [[ ! "$name" =~ $camel_case_regex ]]; then
                echo "::error file=$bwm_file::Path parameter '$name' must be camelCase"
                path_param_violations=$((path_param_violations + 1))
              fi
            done
            if [[ "$path_param_violations" -eq 0 ]]; then
              echo "‚úÖ Path parameters passed camelCase validation."
            fi
          else
            echo "‚ÑπÔ∏è No Path Parameters found. Skipping path parameter name validation."
          fi

          # Query Parameters
          mapfile -t query_params < <(grep 'parameterMapping' "$bwm_file" | grep 'parameterType="Query"')
          if [[ ${#query_params[@]} -gt 0 ]]; then
            echo "üîπ Validating Query Parameters..."
            for line in "${query_params[@]}"; do
              name=$(echo "$line" | grep -oP 'parameterName="\K[^"]+')
              echo "- Query parameter: $name"
              if [[ ! "$name" =~ $camel_case_regex ]]; then
                echo "::error file=$bwm_file::Query parameter '$name' must be camelCase"
                query_param_violations=$((query_param_violations + 1))
              fi
            done
            if [[ "$query_param_violations" -eq 0 ]]; then
              echo "‚úÖ Query parameters passed camelCase validation."
            fi
          else
            echo "‚ÑπÔ∏è No Query Parameters found. Skipping query parameter name validation."
          fi

          total_violations=$((path_format_violations + path_param_violations + query_param_violations))
          echo "rest_naming_violations=$total_violations" >> "$GITHUB_OUTPUT"

      - name: Fail job if any violations found
        if: |
          steps.validate_projects.outputs.project_violations != '0' || 
          steps.validate_processes.outputs.process_violations != '0' || 
          steps.validate_substvar.outputs.substvar_violations != '0' ||
          steps.validate_process_structure.outputs.structure_violations != '0' ||
          steps.validate_rest_naming.outputs.rest_naming_violations != '0'
        run: |
          echo "‚ùå Validation errors detected. Failing the job."
          exit 1
