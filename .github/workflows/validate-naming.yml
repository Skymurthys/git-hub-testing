name: validate-naming

on:
  push:
    branches:
      - test-branch

jobs:
  validate-naming:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Validate project names (.project files) for kebab-case
        id: validate_projects
        shell: bash
        continue-on-error: true
        run: |
          echo "üîç STEP 1: Validating project names (.project files) for kebab-case..."
          violations=0

          is_kebab_case() {
            [[ "$1" =~ ^[a-z0-9]+(-[a-z0-9]+)*$ ]]
          }

          IFS=$'\n'
          project_files=($(find . -type f -name ".project"))

          echo "----------------üîé Found ${#project_files[@]} .project files----------------"

          for project_file in "${project_files[@]}"; do
            proj_name=$(grep -oPm1 '(?<=<name>)[^<]+' "$project_file" || echo "")

            if [[ -z "$proj_name" ]]; then
              echo "‚ùå ERROR: No <name> tag found in $project_file"
              echo "::error file=$project_file::Missing <name> tag"
              violations=$((violations + 1))
              continue
            fi

            if [[ "$proj_name" == *.module ]]; then
              core_name="${proj_name%.module}"
            elif [[ "$proj_name" == *.parent ]]; then
              core_name="${proj_name%.parent}"
            else
              core_name="$proj_name"
            fi
            
            # ‚õî Must start with "om-"
            if [[ ! "$core_name" =~ ^om- ]]; then
              echo "‚ùå ERROR: Project name '$proj_name' must start with 'om-' (found in $project_file)"
              echo "::error file=$project_file::Project name '$proj_name' must start with 'om-'"
              violations=$((violations + 1))
            fi
            
            # ‚õî Length check
            if (( ${#core_name} > 50 )); then
              echo "‚ùå ERROR: Project name '$proj_name' exceeds 50 characters (found in $project_file)"
              echo "::error file=$project_file::Project name '$proj_name' exceeds 50 characters (limit: 50)"
              violations=$((violations + 1))
            fi
            
            # ‚õî Kebab-case check
            if ! is_kebab_case "$core_name"; then
              echo "‚ùå ERROR: Invalid project name '$proj_name' (found in $project_file)"
              echo "::error file=$project_file::Invalid project name '$proj_name'. Expected kebab-case"
              violations=$((violations + 1))
            fi
          done
          
          # ‚úÖ Success message if no violations
          if [[ "$violations" -eq 0 ]]; then
            echo "‚úÖ All project names are valid (start with 'om-', are ‚â§ 50 chars, and in kebab-case)."
          fi

          echo "project_violations=$violations" >> "$GITHUB_OUTPUT"

      - name: Validate process, activity, variable, and schema names
        id: validate_processes
        shell: bash
        continue-on-error: true
        run: |
         echo "üîç STEP 2: Validating naming conventions (processes, activities, variables, schemas)..."

            camel_case_regex='^[a-z]+([A-Z][a-z0-9]*)*$'
            pascal_case_regex='^[A-Z][a-z0-9]+([A-Z][a-z0-9]*)*$'
            special_char_regex='[%$@_#]'

            violations=0

            # ‚úÖ PROCESS FILE (.bwp) checks
            mapfile -t bwp_files < <(find . -type f -path "*/*.module/Processes/*/*.bwp")
            echo "----------------üîé Found ${#bwp_files[@]} .bwp files----------------"

            bwp_violations=0

            for file in "${bwp_files[@]}"; do
              filename=$(basename "$file")
              base="${filename%.bwp}"

              # Check process name
              if [[ ! "$base" =~ $camel_case_regex ]]; then
                echo "‚ùå ERROR: Process name '$base' must be camelCase (found in $file)"
                echo "::error file=$file::Invalid process name '$base'. Must be camelCase"
                violations=$((violations + 1))
                bwp_violations=$((bwp_violations + 1))
              fi

              if [[ "$base" =~ $special_char_regex ]]; then
                echo "‚ùå ERROR: Process name '$base' contains special characters (found in $file)"
                echo "::error file=$file::Special characters not allowed in process name '$base'"
                violations=$((violations + 1))
                bwp_violations=$((bwp_violations + 1))
              fi

              # ‚úÖ ACTIVITY (task name) checks inside each .bwp
              echo "----------------üîé Checking activity (task) names in: $filename----------------"
              mapfile -t tasks < <(grep -oP '<[^:>]*task\b[^>]*name="\K[^"]+' "$file")

              task_errors=0
              for task in "${tasks[@]}"; do
                if [[ ! "$task" =~ $pascal_case_regex ]]; then
                  echo "‚ùå ERROR: Activity name '$task' in $filename must be PascalCase"
                  echo "::error file=$file::Activity name '$task' must be PascalCase"
                  violations=$((violations + 1))
                  task_errors=$((task_errors + 1))
                fi
                if [[ "$task" =~ $special_char_regex ]]; then
                  echo "‚ùå ERROR: Activity name '$task' contains special characters"
                  echo "::error file=$file::Special characters not allowed in activity name '$task'"
                  violations=$((violations + 1))
                  task_errors=$((task_errors + 1))
                fi
              done
              
              if [[ $task_errors -eq 0 ]]; then
                echo "‚úÖ All activity names are valid in $filename and contain no special characters."
              fi

            done

            if [[ "$bwp_violations" -eq 0 ]]; then
              echo "‚úÖ All .bwp process filenames follow camelCase and contain no special characters."
            fi

            # ‚úÖ VARIABLE (.jsv / .msv) checks
            mapfile -t var_files < <(find . -type f \( -path "*/*.module/META-INF/module.jsv" -o -path "*/*.module/META-INF/module.msv" \))
            echo "----------------üîé Found ${#var_files[@]} variable files (.jsv/.msv)----------------"

            jsv_violations=0
            msv_violations=0

            for vfile in "${var_files[@]}"; do
              filename=$(basename "$vfile")

              if [[ "$vfile" == *.jsv ]]; then
                vnames=$(grep -oP '<jobSharedVariable name="\K[^"]+' "$vfile" || true)
                var_type=".jsv"
              else
                vnames=$(grep -oP '<moduleSharedVariable name="\K[^"]+' "$vfile" || true)
                var_type=".msv"
              fi

              var_count=$(echo "$vnames" | grep -c . || true)

              if [[ "$var_count" -eq 0 ]]; then
                echo "üìÑ $filename ($var_type) contains 0 variables."
              else
                echo "üìÑ $filename ($var_type) contains $var_count variable(s):"
                echo "$vnames" | sed 's/^/   - /'
              fi

              while IFS= read -r var; do
                if [[ -z "$var" ]]; then continue; fi

                if [[ ! "$var" =~ $camel_case_regex ]]; then
                  echo "‚ùå ERROR: Variable '$var' in $filename must be camelCase"
                  echo "::error file=$vfile::Variable '$var' must be camelCase"
                  violations=$((violations + 1))
                  [[ "$var_type" == ".jsv" ]] && jsv_violations=$((jsv_violations + 1))
                  [[ "$var_type" == ".msv" ]] && msv_violations=$((msv_violations + 1))
                fi

                if [[ "$var" =~ $special_char_regex ]]; then
                  echo "‚ùå ERROR: Variable '$var' in $filename contains special characters"
                  echo "::error file=$vfile::Special characters not allowed in variable name '$var'"
                  violations=$((violations + 1))
                  [[ "$var_type" == ".jsv" ]] && jsv_violations=$((jsv_violations + 1))
                  [[ "$var_type" == ".msv" ]] && msv_violations=$((msv_violations + 1))
                fi
              done <<< "$vnames"
            done

            if [[ "$jsv_violations" -eq 0 ]]; then
              echo "‚úÖ All variables in .jsv files follow camelCase and contain no special characters."
            fi

            if [[ "$msv_violations" -eq 0 ]]; then
              echo "‚úÖ All variables in .msv files follow camelCase and contain no special characters."
            fi

            # ‚úÖ GLOBAL VARIABLE (default.substvar) checks
            mapfile -t default_substvars < <(find . -type f -path "*/*.module/META-INF/default.substvar")

            echo "----------------üîé Found Global Variable configuration in default.substvar file----------------"

            gv_name_violations=0
            camel_case_regex='^[a-z]+([A-Z][a-z0-9]*)*$'
            special_char_regex='[^a-zA-Z0-9]'
            total_vars=0
            bw_vars=0

            for file in "${default_substvars[@]}"; do
              echo "üìÑ Checking: $file"

              # Extract all <name> elements
              mapfile -t names < <(grep -oP '(?<=<name>).*?(?=</name>)' "$file")

              if [[ "${#names[@]}" -eq 0 ]]; then
                echo "‚ö†Ô∏è  No <name> elements found in $file"
                continue
              fi
              echo "üîπ Checking global variables and ignored system variable"
              for full_name in "${names[@]}"; do
                # Extract last segment after last slash
                var_name="${full_name##*/}"

                # Skip empty names
                if [[ -z "$var_name" ]]; then
                  continue
                fi
                
                total_vars=$((total_vars + 1))
                
                # Skip BW.* system variables
                if [[ "$var_name" == BW.* ]]; then
                  bw_vars=$((bw_vars + 1))
                  continue
                fi
                
                # Validate camelCase
                if [[ ! "$var_name" =~ $camel_case_regex ]]; then
                  echo "‚ùå ERROR: Variable '$var_name' must be camelCase"
                  echo "::error file=$file::Variable '$var_name' must be camelCase"
                  violations=$((violations + 1))
                  gv_name_violations=$((gv_name_violations + 1))
                fi

                # Check for special characters
                if [[ "$var_name" =~ $special_char_regex ]]; then
                  echo "‚ùå ERROR: Variable '$var_name' contains special characters"
                  echo "::error file=$file::Special characters not allowed in variable name '$var_name'"
                  violations=$((violations + 1))
                  gv_name_violations=$((gv_name_violations + 1))
                fi
              done
            done
            
            echo "üî¢ Total Variables Found: $total_vars"
            echo "üî¢ System Variables (BW.*): $bw_vars"
            echo "üî¢ User-defined Variables Checked: $((total_vars - bw_vars))"

            if [[ "$gv_name_violations" -eq 0 ]]; then
              echo "‚úÖ All gloabal variable names follow camelCase and contain no special characters."
            fi

          # ‚úÖ SCHEMA (.xsd) checks
          mapfile -t xsd_files < <(find . -type f -path "*/*.module/Schemas/*.xsd")
          echo "----------------üîé Found ${#xsd_files[@]} schema files (.xsd)----------------"

          xsd_violations=0

          for xsd in "${xsd_files[@]}"; do
            filename=$(basename "$xsd")
            xname="${filename%.xsd}"

            if [[ ! "$xname" =~ $camel_case_regex ]]; then
              echo "‚ùå ERROR: Schema '$xname' must be camelCase"
              echo "::error file=$xsd::Schema filename '$xname.xsd' must be camelCase"
              violations=$((violations + 1))
              xsd_violations=$((xsd_violations + 1))
            fi
            if [[ "$xname" =~ $special_char_regex ]]; then
              echo "‚ùå ERROR: Schema name '$xname' contains special characters"
              echo "::error file=$xsd::Special characters not allowed in schema name '$xname'"
              violations=$((violations + 1))
              xsd_violations=$((xsd_violations + 1))
            fi
          done

          if [[ "$xsd_violations" -eq 0 ]]; then
            echo "‚úÖ All .xsd schema filenames follow camelCase and contain no special characters."
          fi
          
          # üîö Final summary for naming convention checks
          if [[ "$violations" -eq 0 ]]; then
            echo "‚úÖ All naming conventions (process, activity, variable, schema) are satisfied."
          fi

          # üîÑ Export the result for GitHub Actions downstream usage
          echo "naming_violations=$violations" >> "$GITHUB_OUTPUT"


      - name: Validate presence of .substvar files in META-INF folders for specific environments
        id: validate_substvar
        shell: bash
        continue-on-error: true
        run: |
          echo "üîç STEP 3: Checking for .substvar files in META-INF folders..."

          violations=0
          envs="DEV4 IT UAT ST PT AM"

          # Step 1: Find "META-INF" directories
          mapfile -t meta_dirs < <(find . -type d -name META-INF ! -path "*/.*/*")

          # Step 2: Filter valid application directories (exclude paths like *.module)
          declare -A seen
          app_dirs=()
          for meta in "${meta_dirs[@]}"; do
            parent_dir=$(dirname "$meta")
            base=$(basename "$parent_dir" | tr '[:upper:]' '[:lower:]')
            if [[ "$parent_dir" == *".module"* ]]; then
              continue
            fi
            if [[ -z "${seen[$base]}" ]]; then
              seen[$base]=1
              app_dirs+=("$parent_dir")
            fi
          done

          echo "----------------üîé Applications to validate:----------------"
          for app in "${app_dirs[@]}"; do echo "$app"; done

          # Step 3: Check for each expected .substvar file
          for app_dir in "${app_dirs[@]}"; do
            meta_inf="$app_dir/META-INF"
            echo "üì¶ Validating application: $app_dir"

            for env in $envs; do
              if find "$meta_inf" -type f -iname "$env.substvar" | grep -iq "$env.substvar"; then
                echo "‚úÖ Found $env.substvar in $meta_inf"
              else
                echo "‚ö†Ô∏è Environment .substvar not found: $meta_inf/$env.substvar"
                echo "::warning file=$meta_inf/$env.substvar::Missing $env.substvar"
                violations=$((violations + 1))
              fi
            done
          done
          
          if [[ "$violations" -eq 0 ]]; then
            echo "‚úÖ Application has all environment .substvar files"
          fi

          echo "substvar_violations=$violations" >> "$GITHUB_OUTPUT"
          
      - name: Validate required subfolders in Processes directory of the .module
        id: validate_process_structure
        shell: bash
        continue-on-error: true
        run: |
          echo "üîç STEP 4: Validating Processes subfolders (Frontend, Backend, Orchestration)..."

          violations=0
          expected_subdirs=("Frontend" "Backend" "Orchestration")

          module_dir=$(find . -type d -name "*.module" | head -n 1)
          processes_dir="$module_dir/Processes"

          echo "üìÇ Checking: $processes_dir"

          for sub in "${expected_subdirs[@]}"; do
            sub_dir="$processes_dir/$sub"
            if [[ ! -d "$sub_dir" ]]; then
              echo "‚ùå ERROR: Missing subfolder '$sub' in $processes_dir"
              echo "::error file=$sub_dir::$sub folder missing in Processes"
              violations=$((violations + 1))
            fi
          done

          if [[ "$violations" -eq 0 ]]; then
            echo "‚úÖ All Processes folders contain Frontend, Backend, and Orchestration subdirectories."
          fi

          echo "structure_violations=$violations" >> "$GITHUB_OUTPUT"
          
      - name: Validate REST path and parameter naming
        id: validate_rest_naming
        shell: bash
        continue-on-error: false
        run: |
          echo "----------------üîç Searching for module.bwm file under *.module/META-INF/... ----------------üîé
          mapfile -t bwm_file < <(find . -type f -path "*/*.module/META-INF/module.bwm")

          if [[ -z "$bwm_file" ]]; then
            echo "‚ùå ERROR: No module.bwm file found under any *.module/META-INF/"
            exit 1
          fi
          echo "‚úÖ Found BWM file: $bwm_file"

          echo "üîç STEP 5: Checking for REST service bindings in $bwm_file ..."
          if ! grep -q 'scaext:binding[^>]*xsi:type="rest:RestServiceBinding"' "$bwm_file"; then
            echo "‚ÑπÔ∏è No REST service bindings found. Nothing to validate."
            exit 0
          fi
          echo "‚úÖ REST service bindings found. Extracting info..."

          #Extracting <component> blocks..."
          component_blocks=()
          current_block=""
          inside_component=0

          while IFS= read -r line; do
            if [[ "$line" =~ \<sca:component ]]; then
              inside_component=1
              current_block="$line"
            elif [[ $inside_component -eq 1 ]]; then
              current_block+=$'\n'"$line"
              if [[ "$line" =~ \</sca:component\> ]]; then
                component_blocks+=("$current_block")
                inside_component=0
              fi
            fi
          done < "$bwm_file"

          #Extracting <composite> block..."
          composite_block=""
          inside_composite=0

          while IFS= read -r line; do
            if [[ "$line" =~ \<[[:space:]]*sca:composite ]]; then
              inside_composite=1
              composite_block="$line"
            elif [[ $inside_composite -eq 1 ]]; then
              composite_block+=$'\n'"$line"
              if [[ "$line" =~ \</[[:space:]]*sca:composite[[:space:]]*\> ]]; then
                inside_composite=0
                break
              fi
            fi
          done < "$bwm_file"

          # Step 2: Extract top-level <sca:service> blocks only (ignore those inside <component>)
          top_level_services=()
          inside_service=0
          inside_component=0
          current_service=""

          while IFS= read -r line; do
            # Track entry into a component to skip nested services
            if [[ "$line" =~ \<[[:space:]]*sca:component ]]; then
              inside_component=1
            elif [[ "$line" =~ \</[[:space:]]*sca:component[[:space:]]*\> ]]; then
              inside_component=0
            fi

            # Detect top-level service start
            if [[ $inside_component -eq 0 && $inside_service -eq 0 && "$line" =~ \<[[:space:]]*sca:service ]]; then
              inside_service=1
              current_service="$line"
              continue
            fi

            # Accumulate service block lines
            if [[ $inside_service -eq 1 ]]; then
              current_service+=$'\n'"$line"

              # Detect end of the service block
              if [[ "$line" =~ \</[[:space:]]*sca:service[[:space:]]*\> ]]; then
                top_level_services+=("$current_service")
                inside_service=0
                current_service=""
              fi
            fi
          done <<< "$composite_block"

          # ‚úÖ Count and print number of top-level services
          echo "‚úÖ Extracted ${#top_level_services[@]} service block(s)"

           violations=0  # Initialize violation counter=0
          
          for component in "${component_blocks[@]}"; do
            process_name=$(grep -oP '<scaext:implementation[^>]*processName="\K[^"]+' <<< "$component" || echo "")
            [[ -z "$process_name" ]] && continue

            mapfile -t service_names < <(grep -oP '<sca:service[^>]*name="\K[^"]+' <<< "$component")
            [[ ${#service_names[@]} -eq 0 ]] && continue

            for svc_name in "${service_names[@]}"; do
              for top_service in "${top_level_services[@]}"; do
                match_name=$(grep -oP '<sca:service[^>]*name="\K[^"]+' <<< "$top_service" || echo "")
                [[ "$match_name" != "$svc_name" ]] && continue

                # Extract REST path
                path=$(grep -oP '<scaext:binding[^>]*xsi:type="rest:RestServiceBinding"[^>]*path="\K[^"]+' <<< "$top_service" || echo "null")

                echo "  ---------------------------"
                echo "  Process Name : $process_name"
                echo "  Service Name : $svc_name"
                echo -n "  REST Path    : $path"

                # Validate kebab-case path (ignoring parameters in curly braces)
                kebab_path=$(sed -E 's/\{[^}]+\}//g' <<< "$path")
                if [[ "$kebab_path" =~ ^(/[a-z0-9]+(-[a-z0-9]+)*)*$ ]]; then
                  echo " --> ‚úÖ valid kebab-case"
                else
                  echo " --> ‚ùå NOT valid kebab-case"
                  violations=$((violations + 1))
                fi

                echo "  Parameters   :"
                param_lines=$(grep -oP '<parameterMapping[^>]*/?>' <<< "$top_service" || true)

                if [[ -z "$param_lines" ]]; then
                  echo "    (none)"
                else
                  while read -r param; do
                    pname=$(grep -oP 'parameterName="\K[^"]+' <<< "$param" || echo "")
                    ptype=$(grep -oP 'parameterType="\K[^"]+' <<< "$param" || echo "")
                    if [[ -n "$pname" && -n "$ptype" ]]; then
                      # Validate camelCase parameter name
                      if [[ "$pname" =~ ^[a-z]+([A-Z][a-z0-9]*)*$ ]]; then
                        echo "    $ptype - $pname -->‚úÖ valid camelCase"
                      else
                        echo "    $ptype - $pname -->‚ùå NOT valid camelCase"
                        violations=$((violations + 1))
                      fi
                    fi
                  done <<< "$param_lines"
                fi
              done
            done
          done

          if [[ "$violations" -eq 0 ]]; then
            echo "‚úÖ All REST paths and parameters follow naming conventions."
          fi

          # Export violations count to GitHub Actions output
          echo "rest_naming_violations=$violations" >> "$GITHUB_OUTPUT"
          
      - name: Fail job if any violations found
        if: |
          steps.validate_projects.outputs.project_violations != '0' || 
          steps.validate_processes.outputs.naming_violations != '0' || 
          steps.validate_substvar.outputs.substvar_violations != '0' ||
          steps.validate_process_structure.outputs.structure_violations != '0' ||
          steps.validate_rest_naming.outputs.rest_naming_violations != '0'
        run: |
          echo "‚ùå Validation errors detected. Failing the job."

          # Default to 0 if empty or unset
          project_violations="${{ steps.validate_projects.outputs.project_violations || '0' }}"
          process_violations="${{ steps.validate_processes.outputs.naming_violations || '0' }}"
          substvar_violations="${{ steps.validate_substvar.outputs.substvar_violations || '0' }}"
          structure_violations="${{ steps.validate_process_structure.outputs.structure_violations || '0' }}"
          rest_violations="${{ steps.validate_rest_naming.outputs.rest_naming_violations || '0' }}"

          echo ""
          echo "------- Validation Summary -------"
          echo ""
          echo "| Step                     | Violations |"
          echo "|--------------------------|------------|"
          echo "| Project Name Check       | $project_violations |"
          echo "| Process & Activity Names | $process_violations |"
          echo "| Substvar File Presence   | $substvar_violations |"
          echo "| Folder Structure Check   | $structure_violations |"
          echo "| REST Path & Param Check  | $rest_violations |"
          echo ""
          exit 1


